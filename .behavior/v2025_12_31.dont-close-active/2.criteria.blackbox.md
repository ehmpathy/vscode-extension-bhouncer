# usecase.1 = active typing prevents idle closure

given('a user typing in an editor')
  when('the user has been typing within the idle timeout window')
    then('the editor does NOT close due to idle timeout')
      sothat('users never lose editors they are actively working in')
    then('the idle timer resets on each keystroke')
      sothat('continuous editing keeps the editor alive indefinitely')
  when('the user stops typing and the idle timeout elapses')
    then('the editor becomes eligible for idle-based closure')
      sothat('abandoned editors are still cleaned up')

given('a user with the active editor open but not typing')
  when('the idle timeout elapses')
    then('the editor is eligible for closure if bounceOn policy allows IDLE_LIMIT')
      sothat('idle editors free up resources')

# usecase.2 = per-extension closure policy configuration

given('a user configures bounceOn policy per file extension')
  when('policy is set to IDLE_LIMIT for an extension')
    then('editors with that extension close only when idle timeout elapses')
    then('editors with that extension do NOT close due to tabs limit')
      sothat('users can keep many files of that type open indefinitely')
  when('policy is set to TABS_LIMIT for an extension')
    then('editors with that extension close only when tabs limit exceeded and LRU')
    then('editors with that extension do NOT close due to idle timeout')
      sothat('files without language servers stay open while user bounces between them')
  when('policy is set to BOTH for an extension')
    then('editors close on EITHER idle timeout OR tabs limit exceeded')
      sothat('this is the default behavior for resource-heavy file types')

given('no bounceOn policy is configured for an extension')
  when('an editor with that extension exists')
    then('the default policy (BOTH) is used')
      sothat('backwards compatibility is preserved')

# usecase.3 = markdown files default to TABS_LIMIT only

given('a .md file is open')
  when('no explicit bounceOn policy is configured for .md')
    then('the default policy for .md is TABS_LIMIT')
      sothat('markdown files stay open while users reference them')
  when('the idle timeout elapses but tabs limit is not exceeded')
    then('the .md editor remains open')
      sothat('users can bounce between markdown docs without losing them')
  when('tabs limit is exceeded and .md is LRU')
    then('the .md editor closes')
      sothat('workspace still stays tidy')

given('a user explicitly configures bounceOn for .md to BOTH')
  when('the idle timeout elapses')
    then('the .md editor is eligible for closure')
      sothat('user preferences override defaults')

# usecase.4 = language-server file types default to BOTH

given('a .ts file is open')
  when('no explicit bounceOn policy is configured for .ts')
    then('the default policy for .ts is BOTH')
      sothat('typescript language servers are released when editors are idle')
  when('the idle timeout elapses')
    then('the .ts editor is eligible for closure')
      sothat('ts-servers shut down in unused workspaces')

given('a .tf file is open')
  when('no explicit bounceOn policy is configured for .tf')
    then('the default policy for .tf is BOTH')
      sothat('terraform language servers are released when editors are idle')

# usecase.5 = visible/active editor protection

given('an editor is the currently visible/active editor')
  when('idle timeout elapses')
    then('the editor does NOT close if it is the visible editor')
      sothat('users never have their active view yanked away')
  when('user switches to another editor')
    then('the prior editor becomes eligible for pruning per its policy')
      sothat('non-visible editors are still managed')

# boundary.1 = keystroke tracking scope

given('a user edits a file via terminal commands (not vscode editor)')
  when('the terminal modifies the file')
    then('this does NOT reset the idle timer')
      sothat('only editor keystrokes count as activity')

given('a user types in vscode editor')
  when('the document changes event fires')
    then('the idle timer resets for that editor')
      sothat('typing activity is properly tracked')

# boundary.2 = policy configuration shape

given('a user configures bhouncer.editors.bounceOnByExtension')
  when('configuration is { ".md": "TABS_LIMIT", ".ts": "BOTH" }')
    then('.md files use TABS_LIMIT policy')
    then('.ts files use BOTH policy')
    then('unconfigured extensions use default BOTH')
      sothat('configuration is explicit per extension')

# boundary.3 = edge case - new unsaved files

given('a new unsaved file (no extension yet)')
  when('the file has no extension')
    then('the default policy (BOTH) applies')
      sothat('untitled files are still managed')
