# blueprint: bhouncer

A VSCode extension that bouncers your editors and language servers - kicks out the ones that shouldn't be there.

## approach

VSCode extension that:
1. Listens to editor open/close events
2. Tracks which file types are currently open
3. Enables/disables language servers dynamically
4. Kills the specific PID when disabling (using before/after diff to identify it)

## implementation

```ts
// extension.ts
import * as vscode from 'vscode';
import { execSync } from 'child_process';

interface LanguageServerConfig {
  extensions: string[];           // e.g., ['.tf', '.tfvars']
  settingKey: string;             // e.g., 'terraform.languageServer.enable'
  processPattern: string;         // e.g., 'terraform-ls'
}

const LANGUAGE_SERVERS: LanguageServerConfig[] = [
  {
    extensions: ['.tf', '.tfvars'],
    settingKey: 'terraform.languageServer.enable',
    processPattern: 'terraform-ls',
  },
  // can add more: eslint, yaml, etc.
];

// track PIDs per language server
const trackedPids = new Map<string, number>();

function getPids(pattern: string): Set<string> {
  try {
    const output = execSync(`pgrep -f "${pattern}"`, { encoding: 'utf8' });
    return new Set(output.trim().split('\n').filter(Boolean));
  } catch {
    return new Set(); // no processes found
  }
}

function hasOpenEditorsWithExtension(extensions: string[]): boolean {
  return vscode.window.tabGroups.all
    .flatMap(g => g.tabs)
    .some(tab => {
      if (tab.input instanceof vscode.TabInputText) {
        return extensions.some(ext => tab.input.uri.fsPath.endsWith(ext));
      }
      return false;
    });
}

async function enableLanguageServer(config: LanguageServerConfig) {
  const settings = vscode.workspace.getConfiguration();
  const currentValue = settings.get(config.settingKey);

  if (currentValue === true) return; // already enabled

  // capture PIDs before
  const before = getPids(config.processPattern);

  // enable the language server
  await settings.update(config.settingKey, true, vscode.ConfigurationTarget.Workspace);

  // wait for it to spawn
  await new Promise(r => setTimeout(r, 2000));

  // find the new PID
  const after = getPids(config.processPattern);
  for (const pid of after) {
    if (!before.has(pid)) {
      trackedPids.set(config.settingKey, parseInt(pid));
      break;
    }
  }
}

async function disableLanguageServer(config: LanguageServerConfig) {
  const settings = vscode.workspace.getConfiguration();

  // disable the setting
  await settings.update(config.settingKey, false, vscode.ConfigurationTarget.Workspace);

  // kill the tracked PID
  const pid = trackedPids.get(config.settingKey);
  if (pid) {
    try {
      process.kill(pid);
    } catch {
      // process may have already exited
    }
    trackedPids.delete(config.settingKey);
  }
}

async function checkAndUpdateLanguageServers() {
  for (const config of LANGUAGE_SERVERS) {
    const hasRelevantFiles = hasOpenEditorsWithExtension(config.extensions);

    if (hasRelevantFiles) {
      await enableLanguageServer(config);
    } else {
      await disableLanguageServer(config);
    }
  }
}

export function activate(context: vscode.ExtensionContext) {
  // check on tab changes
  context.subscriptions.push(
    vscode.window.tabGroups.onDidChangeTabs(() => {
      checkAndUpdateLanguageServers();
    })
  );

  // initial check
  checkAndUpdateLanguageServers();
}

export function deactivate() {
  // cleanup: kill all tracked PIDs
  for (const [, pid] of trackedPids) {
    try {
      process.kill(pid);
    } catch {
      // ignore
    }
  }
}
```

## package.json

```json
{
  "name": "bhouncer",
  "displayName": "Bhouncer",
  "description": "Bounces stale editors and idle language servers to free up memory",
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.74.0"
  },
  "activationEvents": ["*"],
  "main": "./out/extension.js",
  "contributes": {
    "configuration": {
      "title": "Bhouncer",
      "properties": {
        "bhouncer.servers": {
          "type": "array",
          "default": [],
          "description": "Additional language servers to manage"
        }
      }
    }
  }
}
```

## considerations

1. **timing**: need to wait for language server to spawn after enabling setting
2. **per-window PIDs**: the diff approach ensures we only kill the PID we spawned
3. **extension activation**: must activate on startup (`*`) to catch all events
4. **graceful shutdown**: kill tracked PIDs on deactivate
5. **configurable**: allow users to add more language servers via settings

## editor pruning

```ts
// Track last access time per editor
const editorLastAccess = new Map<string, number>();

// Update access time when editor is focused
vscode.window.onDidChangeActiveTextEditor((editor) => {
  if (editor) {
    editorLastAccess.set(editor.document.uri.toString(), Date.now());
  }
});

// Prune stale editors periodically
function pruneEditors() {
  const config = vscode.workspace.getConfiguration('bhouncer.editors');
  const maxOpen = config.get<number>('maxOpen', 10);
  const idleTimeoutMs = config.get<number>('idleTimeoutMinutes', 10) * 60 * 1000;
  const now = Date.now();

  // Get all tabs with their last access times
  const tabs: { tab: vscode.Tab; uri: string; lastAccess: number }[] = [];

  for (const group of vscode.window.tabGroups.all) {
    for (const tab of group.tabs) {
      if (tab.input instanceof vscode.TabInputText) {
        const uri = tab.input.uri.toString();
        const lastAccess = editorLastAccess.get(uri) ?? 0;
        tabs.push({ tab, uri, lastAccess });
      }
    }
  }

  // Sort by last access (most recent first)
  tabs.sort((a, b) => b.lastAccess - a.lastAccess);

  // Determine which tabs to close
  const tabsToClose: vscode.Tab[] = [];

  tabs.forEach((item, index) => {
    const isOverLimit = index >= maxOpen;
    const isIdle = (now - item.lastAccess) > idleTimeoutMs;

    // Close if over limit AND idle (don't close recently used even if over limit)
    // OR if idle beyond timeout regardless of position
    if ((isOverLimit && isIdle) || (isIdle && item.lastAccess > 0)) {
      tabsToClose.push(item.tab);
    }
  });

  // Close the tabs
  if (tabsToClose.length > 0) {
    vscode.window.tabGroups.close(tabsToClose);
  }
}

// Run pruning on interval
setInterval(pruneEditors, 60 * 1000); // check every minute
```

## settings

```json
{
  "bhouncer.editors.maxOpen": {
    "type": "number",
    "default": 10,
    "description": "Maximum number of editors to keep open"
  },
  "bhouncer.editors.idleTimeoutMinutes": {
    "type": "number",
    "default": 10,
    "description": "Close editors idle for longer than this (minutes)"
  },
  "bhouncer.editors.excludePatterns": {
    "type": "array",
    "default": [],
    "description": "Glob patterns for files to never auto-close (e.g., ['**/package.json'])"
  },
  "bhouncer.editors.excludePinned": {
    "type": "boolean",
    "default": true,
    "description": "Never auto-close pinned tabs"
  }
}
```

## full activation flow

```
1. Extension activates on startup
2. Registers event listeners:
   - onDidChangeActiveTextEditor -> update last access time
   - onDidChangeTabs -> check language servers
3. Starts interval timer for editor pruning (every 1 min)
4. On each prune cycle:
   a. Close editors idle > M minutes
   b. Close oldest editors if count > N
   c. Check which file types remain open
   d. Disable language servers for types with no open files
   e. Kill tracked PIDs for disabled servers
```

## future enhancements

- memory threshold: disable when system memory is low
- status bar indicator: show which language servers are active / editors open
- support more language servers out of the box (eslint, yaml, json, etc.)
- command palette: "Prune Editors Now" manual trigger
- exclude dirty (unsaved) files from auto-close

